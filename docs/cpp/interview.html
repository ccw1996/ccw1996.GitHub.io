<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-cpp/interview">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">C++面试考点 | 萝卜菜在种树</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ccw1996.github.io/docs/cpp/interview"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="C++面试考点 | 萝卜菜在种树"><meta data-rh="true" name="description" content="引用和指针的区别"><meta data-rh="true" property="og:description" content="引用和指针的区别"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ccw1996.github.io/docs/cpp/interview"><link data-rh="true" rel="alternate" href="https://ccw1996.github.io/docs/cpp/interview" hreflang="en"><link data-rh="true" rel="alternate" href="https://ccw1996.github.io/docs/cpp/interview" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="萝卜菜在种树 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="萝卜菜在种树 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.79f0d40c.css">
<link rel="preload" href="/assets/js/runtime~main.5a90f2f0.js" as="script">
<link rel="preload" href="/assets/js/main.b3b3576b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">My Site</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search searchBarContainer_NW3z"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div><div class="searchHintContainer_Pkmr"><kbd class="searchHint_iIMx">ctrl</kbd><kbd class="searchHint_iIMx">K</kbd></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/LLM">LLM</a><button aria-label="Toggle the collapsible sidebar category &#x27;LLM&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/cpp">cpp</a><button aria-label="Toggle the collapsible sidebar category &#x27;cpp&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/summarycpp">总结 C/C++ 知识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/CRTP">CRTP</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/cpp/STL">STL</a><button aria-label="Toggle the collapsible sidebar category &#x27;STL&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/constexpr">c++之constexpr</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/cpp14">C++14 新特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/cpp17">C++17常用新特性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/inline">inline 总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/cpp/interview">C++面试考点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/multi_thread">多线程总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/perfect_forwarding">C++11完美转发及实现方法详解</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/rvalue">左值和右值</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/tag_invoke">tag_invoke</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/cpp/template_cpp">C++模板</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/cpp/work">work</a><button aria-label="Toggle the collapsible sidebar category &#x27;work&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/cuda">cuda</a><button aria-label="Toggle the collapsible sidebar category &#x27;cuda&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/design_model">design_model</a><button aria-label="Toggle the collapsible sidebar category &#x27;design_model&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/ml">ml</a><button aria-label="Toggle the collapsible sidebar category &#x27;ml&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/other">other</a><button aria-label="Toggle the collapsible sidebar category &#x27;other&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/python">python</a><button aria-label="Toggle the collapsible sidebar category &#x27;python&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/stable_diffusion">stable_diffusion</a><button aria-label="Toggle the collapsible sidebar category &#x27;stable_diffusion&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/triton">triton</a><button aria-label="Toggle the collapsible sidebar category &#x27;triton&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/cpp"><span itemprop="name">cpp</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">C++面试考点</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>C++面试考点</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="引用和指针的区别">引用和指针的区别<a href="#引用和指针的区别" class="hash-link" aria-label="Direct link to 引用和指针的区别" title="Direct link to 引用和指针的区别">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">初始化:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **引用在定义的时候必须进行初始化**，并且不能够改变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    指针在定义的时候不一定要初始化，并且指向的空间可变</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">访问逻辑不同:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    通过指针访问对象, 用户需要使用间接访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    通过引用访问对象, 用户只需使用直接访问, 编译器负责将其处理为间接访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">运算结果不同:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **传指针的实质是传值，传递的值是指针内储存的变量地址**；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    传引用的实质是传地址，传递的是变量的地址。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    指针通过下标运算结果是指针所指值为基地址加上偏移, 且基地址可变.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    引用通过下标运算结果是引用的是数组才能有这个操作.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    自增运算结果不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `sizeof`运算的结果不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    下标运算:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    函数参数:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    多级: 有多级指针，但是没有多级引用，只能有一级引用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[C++ 引用占用内存](https://blog.csdn.net/toyijiu/article/details/99729949)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    引用实际是通过指针实现的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    引用是一个常量指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    引用在内存中占4个字节。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在对引用定义时，需要对这个常量指针初始化。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="c中的指针参数传递和引用参数传递">C++中的指针参数传递和引用参数传递<a href="#c中的指针参数传递和引用参数传递" class="hash-link" aria-label="Direct link to C++中的指针参数传递和引用参数传递" title="Direct link to C++中的指针参数传递和引用参数传递">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">**指针参数传递的本质是值传递, 传递的值是对象的地址**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**引用参数传递的本质是传地址, 传递的是实参变量的地址**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">从逻辑上引用相当于对变量起了一个别名, 通过该别名可以对变量进行直接访问, 由编译器负责将直接访问转换为间接访问; 而指针访问变量都是间接访问.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="形参与实参的区别">形参与实参的区别<a href="#形参与实参的区别" class="hash-link" aria-label="Direct link to 形参与实参的区别" title="Direct link to 形参与实参的区别">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">形参属于函数内部的局部变量, 在调用函数时才会分配内存, 在函数调用之后会被释放掉, 因此在函数内部才有效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">实参可以使常量, 表达式, 函数等, 无论是何种类型,在函数调用时都必须有一个确定的值,以便把函数的值传递给形参</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">实参和形参的个数一定要严格匹配(当然可以忽略有默认值形参), 通常情况下函数类型也是应该严格匹配的, 但是允许隐式类型变换,如果类中定义了零参数构造函数,甚至可以使用空初始化列表 `{}` 的方式调用零参数构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">实参到形参的传递是单向的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">形参类型为非指针非引用, 则传递方式为值传递则, 形参为实参的副本, 对形参的任何修改都不会反应在主调函数中</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="static的用法"><code>static</code>的用法<a href="#static的用法" class="hash-link" aria-label="Direct link to static的用法" title="Direct link to static的用法">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">主要可以分为五个类型: 全局静态变量, 局部静态变量, 静态函数, 静态成员变量, 静态成员函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">### 静态函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在函数返回类型前加`static`，函数就定义为静态函数。**函数的定义和声明在默认情况下都是`extern`的**，但**静态函数只是在声明他的文件当中可见，不能被其他文件所用**。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    函数的实现使用`static`修饰，**那么这个函数只可在本`cpp`内使用，不会同其他`cpp`中的同名函数引起冲突；**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `warning`：不要再头文件中声明`static`的全局函数，不要在`cpp`内声明非`static`的全局函数，如果你要在多个`cpp`中复用该函数，就把它的声明提到头文件里去，否则`cpp`内部声明需加上`static`修饰；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">### 类的静态成员</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    因此，**静态成员是类的所有对象中共享的成员，而不是某个对象的成员**。对多个对象来说，静态数据成员只存储一处，供所有对象共用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">### 类的静态函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员**。因此，对静态成员的引用不需要用对象名。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员(这点非常重要)**。*如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：::();*参数表&gt;静态成员函数名&gt;类名&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    不能被`virtual`修饰,静态成员函数没有`this` 指针，虚函数的实现是为每一个对象分配一个`vptr` 指针，而`vptr` 是通过`this` 指针调用的，所以不能为`virtual`；虚函数的调用关系，`this`-&gt;`vptr`-&gt;`ctable`-&gt;`virtual function`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="静态变量什么时候初始化">静态变量什么时候初始化<a href="#静态变量什么时候初始化" class="hash-link" aria-label="Direct link to 静态变量什么时候初始化" title="Direct link to 静态变量什么时候初始化">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">但在 `C`  和 `C++` 中静态局部变量的初始化节点又有点不太一样。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在`C`中，**初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化**，所以我们看到^^在`C` 语言中无法使用变量对静态局部变量进行初始化^^，在程序运行结束，变量所处的全局内存会被全部回收。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">而在`C++`中，**初始化时在执行相关代码时才会进行初始化**，主要是由于`C++`引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以 **`C++`标准规定为全局或静态对象是有首次用到时才会进行构造** ，并通过`atexit()`来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在 **`C++`中是可以使用变量对静态局部变量进行初始化的。**</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="mutable"><code>mutable</code><a href="#mutable" class="hash-link" aria-label="Direct link to mutable" title="Direct link to mutable">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">如果需要在 `const`  成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为 `mutable` 。**即用`mutable` 修饰的成员变量不受`const` 成员方法的限制;**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可以认为 `mutable`  的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于 `const_cast` 的存在，这个概念很多时候用处不是很到了。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="extern-用法"><code>extern</code> 用法？<a href="#extern-用法" class="hash-link" aria-label="Direct link to extern-用法" title="Direct link to extern-用法">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">`extern`  修饰变量的声明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果文件`a.c` 需要引用`b.c` 中变量`int v`，就可以在`a.c` 中声明`extern int v`，然后就可以引用变量`v`。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">`extern`  修饰函数的声明</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果文件`a.c` 需要引用`b.c` 中的函数，比如在`b.c` 中原型是`int fun(int mu)`，那么就可以在`a.c` 中声明`extern int fun(int mu)`，然后就能使用`fun` 来做任何事情。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    就像变量的声明一样，`extern int fun(int mu)`可以放在`a.c` 中任何地方，而不一定非要放在`a.c` 的文件作用域的范围中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    默认情况情况下函数都是`extern`的, 除非使用`static`对函数进行了隐匿</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">`extern`  修饰符可用于指示 `C`  或者 `C++` 函数的调用规范。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    比如在`C++`中调用`C` 库函数，就需要在`C++`程序中用`extern “C”`声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用`C` 函数规范来链接。主要原因是`C++`和`C` 程序编译完成后在目标代码中命名规则不同。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚函数可以声明为inline吗">虚函数可以声明为<code>inline</code>吗?<a href="#虚函数可以声明为inline吗" class="hash-link" aria-label="Direct link to 虚函数可以声明为inline吗" title="Direct link to 虚函数可以声明为inline吗">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">**虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换, 所以不能**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">内联函数用于提高效率, 对于程序中需要频繁使用和调用的小函数非常有用。它是在**编译期间**，对调用内联函数的地方的代码**替换**成函数代码。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类成员初始化方式构造函数的执行顺序为什么用成员初始化列表会快一些">类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？<a href="#类成员初始化方式构造函数的执行顺序为什么用成员初始化列表会快一些" class="hash-link" aria-label="Direct link to 类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？" title="Direct link to 类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">概念</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    赋值初始化，通过在函数体内进行赋值初始化；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    列表初始化，在冒号后使用初始化列表进行初始化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这两种方式的主要区别在于：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    对于在**函数体中初始化**,是在所有的成员函数分配空间后才进行的。**对于类对象类型成员变量, 则是先调用零参数构造函数, 如果零参数构造函数不存在编译器将会报错.**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">快的原因: 所以对于列表初始化: 只进行了一次初始化操作, 而赋值初始化则先进性了一次初始化,然后调用了一次复制构造函数.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">一个派生类构造函数的执行顺序如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **虚基类**的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **基类**的构造函数(多个普通基类也按照继承的顺序执行构造函数)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **类类型的成员对象**的构造函数(按照初始化顺序)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    派生类**自己的构造函数**。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数为什么不能为虚函数析构函数为什么要虚函数">构造函数为什么不能为虚函数？析构函数为什么要虚函数？<a href="#构造函数为什么不能为虚函数析构函数为什么要虚函数" class="hash-link" aria-label="Direct link to 构造函数为什么不能为虚函数？析构函数为什么要虚函数？" title="Direct link to 构造函数为什么不能为虚函数？析构函数为什么要虚函数？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">### 构造函数为什么不能为虚函数?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">首先是没必要使用虚函数:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    由于使用间接调用(通过引用或则指针)导致类**类型不可信**, 而使用虚函数机制完成正确的函数调用.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    但是构造函数本身是为了初始化对象实例, 创建对象必须制定它的类型, 其类类型是明确的, 因此在编译期间即可确定调用函数入口地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    因而没必要使用虚函数, 其调用在编译时由编译器已经确定.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">其次不能使用虚函数:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    虚函数的调用依赖于虚函数表, 虚函数表储存于静态储存区, 在存在虚函数的对象中都将插入一个指向虚函数表的指针,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在对象中插入一个指向虚函数表的指针是由构造函数完成的, 也就是说在调用构造函数时并没有指向虚函数表的指针, 也就不能完成虚函数的调用.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">### 析构函数为什么要虚函数？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">`C++` 中基类采用 `virtual`  虚析构函数是为了防止内存泄漏。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    所以，为了防止这种情况的发生，`C++`中基类的析构函数应采用`virtual` 虚析构函数。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="析构函数的作用如何起作用">析构函数的作用，如何起作用？<a href="#析构函数的作用如何起作用" class="hash-link" aria-label="Direct link to 析构函数的作用，如何起作用？" title="Direct link to 析构函数的作用，如何起作用？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">析构函数名与类名相同,只是在函数名前增加了取反符号 `~` 以区别于构造函数,其不带任何参数, 也**没有返回值**. 也**不允许重载**.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">析构函数与构造函数的作用相反, 当对象生命周期结束的时候,如对象所在函数被调用完毕时,析构函数负责结束对象的生命周期. **注意如果类对象中分配了堆内存一定要在析构函数中进行释放.**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">和拷贝构造函数类似,如果用户未定义析构函数, 编译器**并不是一定**会自动合成析构函数, 只有在**成员变量或则基类**拥有析构函数的情况下它才会自动合成析构函数.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果**成员变量或则基类**拥有析构函数, 则编译器一定会合成析构函数, 负责调用成员变量或则基类的析构函数, 此时如果用户提供了析构函数,则编译器会在用户析构函数之后添加上述代码.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">类析构的顺序为: 派生类析构函数, 对象成员析构函数, 基类析构函数.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数和析构函数可以调用虚函数吗">构造函数和析构函数可以调用虚函数吗<a href="#构造函数和析构函数可以调用虚函数吗" class="hash-link" aria-label="Direct link to 构造函数和析构函数可以调用虚函数吗" title="Direct link to 构造函数和析构函数可以调用虚函数吗">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">在C++中，提倡不在构造函数和析构函数中调用虚函数；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在构造函数和析构函数调用的所有函数(包括虚函数)都是编译时确定的, 虚函数将运行该类中的版本.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">因为**父类对象会在子类之前进行构造**，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">构造顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    基类构造函数、对象成员构造函数、派生类本身的构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">特例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    局部对象，在退出程序块时析构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    静态对象，在定义所在文件结束时析构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    全局对象，在程序结束时析构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    继承对象，先析构派生类，再析构父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    对象成员，先析构类对象，再析构对象成员</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚析构函数的作用父类的析构函数是否要设置为虚函数">虚析构函数的作用，父类的析构函数是否要设置为虚函数？<a href="#虚析构函数的作用父类的析构函数是否要设置为虚函数" class="hash-link" aria-label="Direct link to 虚析构函数的作用，父类的析构函数是否要设置为虚函数？" title="Direct link to 虚析构函数的作用，父类的析构函数是否要设置为虚函数？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">`C++` 中基类采用 `virtual` 虚析构函数是为了防止内存泄漏。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    所以，为了防止这种情况的发生， `C++` 中基类的析构函数应采用 `virtual` 虚析构函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**纯虚析构函数一定得有定义**，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。**因此缺乏任何一个基类析构函数的定义，就会导致链接失败。**^^因此，最好不要把虚析构函数定义为纯虚析构函数。^^</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数---析构函数--可以调用虚函数吗"><code>构造函数</code>   <code>析构函数</code>  可以调用虚函数吗？<a href="#构造函数---析构函数--可以调用虚函数吗" class="hash-link" aria-label="Direct link to 构造函数---析构函数--可以调用虚函数吗" title="Direct link to 构造函数---析构函数--可以调用虚函数吗">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">在 `构造函数` 和 `析构函数` 中最好不要调用虚函数；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在 `构造函数` 和 `析构函数` 中调用的成员函数都是属于**编译时确定**的,并**不具有虚函数的动态绑定特性**, 有如下原因:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **在构造时, 父类对象总是先于子类对象构造**的, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **在析构时, 子类的析构函数总是先于父类**执行, 如果父类的析构函数使用虚函数机制调用子类的函数, 结果将是不可预料的</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="构造函数-----析构函数--可否抛出异常"><code>构造函数</code>  ,    <code>析构函数</code>  可否抛出异常<a href="#构造函数-----析构函数--可否抛出异常" class="hash-link" aria-label="Direct link to 构造函数-----析构函数--可否抛出异常" title="Direct link to 构造函数-----析构函数--可否抛出异常">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">构造函数异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    后果:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        **(原因):** `C++` 拒绝为**没有完成构造函数的对象**调用**析构函数**，原因是避免开销</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        构造函数中发生异常，控制权转出构造函数。如果构造函数中申请了堆内存, 则堆内存将无法释放, 从而造成内存泄漏</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        例如: 在对象 `b` 的构造函数中发生异常，对象 `b` 的析构函数不会被调用。**因此会造成内存泄漏**。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    解决方案:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        使用**智慧指针**来管理堆内存. 其不需要在析构函数中手动释放资源. 在发生异常时, 智慧指针会自动释放资源从而避免了内存泄漏.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        **一般建议不要在构造函数里做过多的资源分配。**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">析构函数异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    后果:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        在异常传递的**堆栈辗转开解**的过程中, 如果发生析构异常,  `C++` 会调用 `terminate` 终止程序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        如果析构函数发生发生异常，则异常后面的代码将不执行，无法确保完成我们想做的清理工作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    解决方法：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        如果异常不可避免，则应在析构函数内捕获，而不应当抛出。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        在析构函数中使用 `try-catch` 块屏蔽所有异常。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    附加说明:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        **(后果1):** 如果某一个异常发生,某对象的析构函数被调用,而此时析构发生了异常并流出了函数之外,则函数会被立即terminate掉(函数外有catch也不能拯救)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类如何实现--只能静态分配--和--只能动态分配">类如何实现  <code>只能静态分配</code>  和  <code>只能动态分配</code><a href="#类如何实现--只能静态分配--和--只能动态分配" class="hash-link" aria-label="Direct link to 类如何实现--只能静态分配--和--只能动态分配" title="Direct link to 类如何实现--只能静态分配--和--只能动态分配">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">只能在堆上建立</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    分析: 类对象只能建立在堆上，就是不能**静态建立类对象**，即不能**直接调用类的构造函数**。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    实现方式: 将**析构函数设为私有或则受保护**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    方法分析:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        静态建立:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            当对象 `建立` 在栈上面时，是由编译器分配内存空间的，调用 `构造函数` 来 `构造` 栈对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            当对象使用 `完` 后，编译器会调用 `析构函数` 来 `释放` 栈对象所占的空间。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            编译器管理了对象的整个生命周期。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        编译器在为类对象**分配栈空间**时，会**先检查类的析构函数的访问性**，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            因此，将析构函数设为私有，类对象就无法建立在栈上了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        由此引发的问题:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            因为析构函数设置为了私有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            需要设置一个 `public函数` 来调用析构函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ``` cpp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          class  A  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          protected :  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              A(){}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              ~A(){}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          public :  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              static  A* create()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  return   new  A();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              void  destory()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  delete   this ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          };  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        只能在栈上建立</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。**将operator new()设为私有即可**。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            **注意: 重载了 `new` 就需要重载 `delete` **</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ``` cpp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  class  A  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  private :  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                      void * operator  new ( size_t  t){}      // 注意函数的第一个参数和返回值都是固定的   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                      void  operator  delete ( void * ptr){}  // 重载了new就需要重载delete   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  public :  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                      A(){}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                      ~A(){}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  }; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ```</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么情况会自动生成默认构造函数">什么情况会自动生成默认构造函数？<a href="#什么情况会自动生成默认构造函数" class="hash-link" aria-label="Direct link to 什么情况会自动生成默认构造函数？" title="Direct link to 什么情况会自动生成默认构造函数？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">四种情况:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    类成员对象带有默认构造函数.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    基类带有默认构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    类中存在虚函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    继承体系中存在虚继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**在合成的默认构造函数中，只有基类子对象和类类型对象会被初始化**，而其他所有的非静态成员(如整数，指针，数组等)，都不会初始化，对他们进行初始化的应该是程序员，而非编译器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">注意：值类型的默认值并不是默认构造的初始化。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是类的继承">什么是类的继承？<a href="#什么是类的继承" class="hash-link" aria-label="Direct link to 什么是类的继承？" title="Direct link to 什么是类的继承？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">类与类之间的关系</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `(has-A)` 包含关系，即一个类的成员属性是另一个已经定义好的类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `(use-A)` 使用关系, 一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式实现；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `(is-A)` 继承关系, 继承关系，关系具有传递性；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承的相关概念</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    被称为子类或者派生类，被继承的类称为父类或者基类；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承的特点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    子类拥有父类的所有属性和方法，子类对象可以当做父类对象使用；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    子类可以拥有父类没有的属性和方法；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承中的访问控制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `public` 、 `protected` 、 `private`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承中的构造和析构函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    子类中构造函数的调用顺序为: 基类构造函数, 成员对象构造函数, 派生类构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    子类中析构函数的调用顺序为: 派生类析构函数, 成员对象析构函数, 基类析构函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承中的兼容性原则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    参考: [继承中的类型兼容性原则 - Say舞步 - 博客园](https://www.cnblogs.com/zhangyaoqi/p/4591571.html)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="抽象基类为什么不能创建对象">抽象基类为什么不能创建对象<a href="#抽象基类为什么不能创建对象" class="hash-link" aria-label="Direct link to 抽象基类为什么不能创建对象" title="Direct link to 抽象基类为什么不能创建对象">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">抽象类的定义：**带有纯虚函数的类**为抽象类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">抽象类的作用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    所以抽象类实际上刻画了一组子类的**操作接口**的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">使用抽象类时注意：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果**派生类中没有给出所有纯虚函数的实现**，而只是继承基类的纯虚函数，则这个**派生类仍然是一个抽象类**。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果**派生类中给出了所有纯虚函数的实现**，则该**派生类就不再是抽象类**了，它是一个可以建立对象的具体的类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **抽象类是不能定义对象的**。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><hr><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">纯虚函数定义: 纯虚函数是一种特殊的虚函数，它的一般格式如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">``` cpp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          class &lt;类名&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">```</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">纯虚函数引入原因</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    在很多情况下，基类本身生成对象是不合情理的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数(方法:  `virtual ReturnType Function()= 0;` )。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **同时含有纯虚函数的类称为抽象类**，它不能生成对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">相似概念</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    多态性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        C++支持两种多态性：编译时多态性，运行时多态性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        编译时多态性(静态多态)：通过重载函数实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        运行时多态性(动态多态)：通过虚函数实现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    虚函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        虚函数是在基类中被声明为 `virtual` ，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    抽象类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="类什么时候会析构">类什么时候会析构？<a href="#类什么时候会析构" class="hash-link" aria-label="Direct link to 类什么时候会析构？" title="Direct link to 类什么时候会析构？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">对于静态对象: 当离开作用区域之后, 对象生命周期结束, 编译器会自动调用析构函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于动态对象: 当对对象指针调用delete时, 会调用析构函数终止对象生命周期并释放内存. 其中对象指针指针可以对象类型的指针, 也可以时基类指针(注意基类析构函数位虚函数)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第三种情况: 当对象中存在嵌入对象时, 该对象析构时, 嵌入对象也会被析构</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="介绍一下c里面的多态">介绍一下C++里面的多态？<a href="#介绍一下c里面的多态" class="hash-link" aria-label="Direct link to 介绍一下C++里面的多态？" title="Direct link to 介绍一下C++里面的多态？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">静态多态(重载, 模板): 是在编译的时候，就确定调用函数的类型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">动态多态(覆盖, 虚函数实现): 在运行的时候，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参考: [理解的虚函数和多态](https://zhaostu4.github.io/2019/11/28/%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB-C++%E5%9F%BA%E7%A1%80/#%E7%90%86%E8%A7%A3%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">函数重载:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    同一可访问区域内, 存在多个不同参数列表的同名函数, 由编译器根据调用参数决定那个函数应该被调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    函数重载不关心返回值类型, 但是对于函数类型时关心的, 例如类中的两个函数拥有相同参数列表的同名函数, 一个为const类型, 一个为非const类型, 依旧时属于函数重载.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">函数模板:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    模板函数会经历两遍编译:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (模板编译)在定义模板函数时对模板本身进行编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (模板实例化)在调用时对参数进行替换, 对替换参数后的代码进行编译</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    虽然它和函数重载类似都可以根据参数确定将要调用的函数版本, 但是函数模板只会生成将要用到的函数版本, 而函数模板无论是否调用其代码都会生成.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">覆盖: 是指派生类中重新定义了基类中的 `virtual` 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，只要函数名相同，基类函数都会被隐藏. 不管参数列表是否相同。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="用c-语言实现c的继承">用C 语言实现C++的继承<a href="#用c-语言实现c的继承" class="hash-link" aria-label="Direct link to 用C 语言实现C++的继承" title="Direct link to 用C 语言实现C++的继承">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">关键点:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    使用函数指针保存函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    将基类放在结构题的头部, 这样强转的就不会出错了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ``` cpp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  #include &lt;iostream&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  using namespace std;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  //C++中的继承与多态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  struct A{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    virtual void fun()  {//C++中的多态:通过虚函数实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cout&lt;&lt;&quot;A:fun()&quot;&lt;&lt;endl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  struct B:public A {//C++中的继承:B 类公有继承A 类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    virtual void fun() { //C++中的多态:通过虚函数实现（子类的关键字virtual 可加可不加）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cout&lt;&lt;&quot;B:fun()&quot;&lt;&lt;endl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  //C 语言模拟C++的继承与多态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  typedef void (*FUN)(); //定义一个函数指针来实现对成员函数的继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  struct _A { //父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    FUN _fun; //由于C 语言中结构体不能包含函数，故只能用函数指针在外面实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int _a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  struct _B { //子类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    _A _a_; //在子类中定义一个基类的对象即可实现对父类的继承</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int _b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  void _fA() { //父类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;_A:_fun()\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  void _fB() { //子类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    printf(&quot;_B:_fun()\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  void Test()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //测试C++中的继承与多态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    A a; //定义一个父类对象a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    B b; //定义一个子类对象b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    A* p1 = &amp;a; //定义一个父类指针指向父类的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p1-&gt;fun(); //调用父类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p1 = &amp;b; //让父类指针指向子类的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p1-&gt;fun(); //调用子类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    //C 语言模拟继承与多态的测试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    _A _a; //定义一个父类对象_a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    _B _b; //定义一个子类对象_b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    _a._fun = _fA; //父类的对象调用父类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    _b._a_._fun = _fB; //子类的对象调用子类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    _A* p2 = &amp;_a; //定义一个父类指针指向父类的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p2-&gt;_fun(); //调用父类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p2 = (_A*)&amp;_b; //让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    p2-&gt;_fun(); //调用子类的同名函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ```</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="继承机制中对象之间如何转换指针和引用之间如何转换">继承机制中对象之间如何转换？指针和引用之间如何转换？<a href="#继承机制中对象之间如何转换指针和引用之间如何转换" class="hash-link" aria-label="Direct link to 继承机制中对象之间如何转换？指针和引用之间如何转换？" title="Direct link to 继承机制中对象之间如何转换？指针和引用之间如何转换？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">派生类的对象可以当做基类对象使用， 例如赋值或则初始化等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">派生类对象的地址可以赋给指向基类的指针。 在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">向上类型转换(派生类转基类, 总是安全的)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，**向上类型转换会自动进行**，而且向上类型转换是安全的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">向下类型转换(基类转派生类, 不安全)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    `RTTI` 技术，用dynamic_cast进行向下类型转换, 只有存在虚函数的类才能使用 `RTTI`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[浅谈C++类型转换的安全性 - freshman94的博客 - CSDN博客](https://blog.csdn.net/qq_22660775/article/details/88715548)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[继承的赋值兼容规则](https://blog.csdn.net/vjhghjghj/article/details/90677092#%C2%A0%E7%BB%A7%E6%89%BF%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99)update</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="组合与继承优缺点">组合与继承优缺点？<a href="#组合与继承优缺点" class="hash-link" aria-label="Direct link to 组合与继承优缺点？" title="Direct link to 组合与继承优缺点？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">继承: 继承是Is a 的关系，比如说Student 继承Person,则说明Student is a Person。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承的优点: 是子类可以重写父类的方法来方便地实现对父类的扩展。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">继承的缺点有以下几点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    父类的**内部细节**对子类是**可见**的。(可以自己调用父类的方法)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><hr><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">组合(嵌入式对象): 组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">组合的优点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的**内部细节**对当前对象时**不可见**的。(必须通过嵌入式对象调用嵌入式对象的方法)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    当前对象可以在运行时动态的绑定所包含的对象。可以通过set 方法给所包含对象赋值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">组合的缺点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    容易产生过多的对象。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    为了能组合多个对象，必须仔细对接口进行定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参考: [继承的优点和缺点](https://blog.csdn.net/u013675978/article/details/82628710)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="左值右值">左值右值<a href="#左值右值" class="hash-link" aria-label="Direct link to 左值右值" title="Direct link to 左值右值">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">lvalue:具名且不可被移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xvaue:具名且可被移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">prvalue:不具名且可被移动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">glvalue:具名，lvalue和xvalue都属于glvalue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rvalue:可被移动的表达式，prvalue和xvalue都属于rvalue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">![image.png](../assets/image_1657769991569_0.png)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">右值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    字面值或者函数返回的非引用都是纯右值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    以下表达式的值都是纯右值：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    字面值(字符串字面值除外)，例如1，&#x27;a&#x27;, true等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    后置自增和自减表达式(a++, a--)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    算术表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    逻辑表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    比较表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    取地址表达式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lambda表达式</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="c-语言的编译链接过程">C 语言的编译链接过程？<a href="#c-语言的编译链接过程" class="hash-link" aria-label="Direct link to C 语言的编译链接过程？" title="Direct link to C 语言的编译链接过程？">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接--&gt;可执行文件</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="虚函数">虚函数<a href="#虚函数" class="hash-link" aria-label="Direct link to 虚函数" title="Direct link to 虚函数">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">简述C++虚函数作用及底层实现原理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    C++中虚函数使用虚函数表和 虚函数表指针实现，虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地 址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的 虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    **如果要生成子类虚表,就要经过三个步骤:**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    第一步,将父类虚表内容**拷贝**到子类虚表上;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    第二步,将子类重**写的虚函数覆盖掉表**中父类的虚函数;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    第三步,如果子类有**新增加**的虚函数,按声明次序加到最后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">一个对象访问普通成员函数和虚函数哪个更快</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    访问普通成员函数更快，因为普通成员函数的地址在编译阶段就已确定，因此在访问时直接调 用对应地址的函数，而虚函数在调用时，需要首先在虚函数表中寻找虚函数所在地址，因此相比普 通成员函数速度要慢一些</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在什么情况下，析构函数需要是虚函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    若存在类继承关系并且析构函数中需要析构某些资源时，析构函数需要是虚函数，否则当使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，造成内存泄露等问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">内联函数、构造函数、静态成员函数可以是虚函数吗</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    都不可以。内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开； 构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类 的，因此不存在动态绑定的概念；静态成员函数是以类为单位的函数，与具体对象无关，虚函数是 与对象动态绑定的，因此是两个不冲突的概念；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的
先去调用(call)派生类中的构造函数， 在进入函数体之前 ，先去调用(call)基类的构造函数，基类构造函数执行完毕后，再继续执行派生类中的构造函数，执行完毕对象创建成功。
基类构造函数的调用是在派生类构造函数初始化列表之前还是之后呢?
虽然在汇编代码中，是先调用的派生类的构造函数，但是总的来说，基类的构造函数还是先于派生类的构造函数里的语句先执行，也就是说，基类对象先于派生类对象被创建。
派生类对象中基类析构函数和派生类析构函数调用顺序
先执行派生类的析构函数，然后再去执行基类的析构函数</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/work">work</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/main/website/docs/cpp/interview.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-10-23T15:43:25.000Z">Oct 23, 2023</time></b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/cpp/inline"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">inline 总结</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/cpp/multi_thread"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">多线程总结</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#引用和指针的区别" class="table-of-contents__link toc-highlight">引用和指针的区别</a></li><li><a href="#c中的指针参数传递和引用参数传递" class="table-of-contents__link toc-highlight">C++中的指针参数传递和引用参数传递</a></li><li><a href="#形参与实参的区别" class="table-of-contents__link toc-highlight">形参与实参的区别</a></li><li><a href="#static的用法" class="table-of-contents__link toc-highlight"><code>static</code>的用法</a></li><li><a href="#静态变量什么时候初始化" class="table-of-contents__link toc-highlight">静态变量什么时候初始化</a></li><li><a href="#mutable" class="table-of-contents__link toc-highlight"><code>mutable</code></a></li><li><a href="#extern-用法" class="table-of-contents__link toc-highlight"><code>extern</code> 用法？</a></li><li><a href="#虚函数可以声明为inline吗" class="table-of-contents__link toc-highlight">虚函数可以声明为<code>inline</code>吗?</a></li><li><a href="#类成员初始化方式构造函数的执行顺序为什么用成员初始化列表会快一些" class="table-of-contents__link toc-highlight">类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？</a></li><li><a href="#构造函数为什么不能为虚函数析构函数为什么要虚函数" class="table-of-contents__link toc-highlight">构造函数为什么不能为虚函数？析构函数为什么要虚函数？</a></li><li><a href="#析构函数的作用如何起作用" class="table-of-contents__link toc-highlight">析构函数的作用，如何起作用？</a></li><li><a href="#构造函数和析构函数可以调用虚函数吗" class="table-of-contents__link toc-highlight">构造函数和析构函数可以调用虚函数吗</a></li><li><a href="#虚析构函数的作用父类的析构函数是否要设置为虚函数" class="table-of-contents__link toc-highlight">虚析构函数的作用，父类的析构函数是否要设置为虚函数？</a></li><li><a href="#构造函数---析构函数--可以调用虚函数吗" class="table-of-contents__link toc-highlight"><code>构造函数</code>   <code>析构函数</code>  可以调用虚函数吗？</a></li><li><a href="#构造函数-----析构函数--可否抛出异常" class="table-of-contents__link toc-highlight"><code>构造函数</code>  ,    <code>析构函数</code>  可否抛出异常</a></li><li><a href="#类如何实现--只能静态分配--和--只能动态分配" class="table-of-contents__link toc-highlight">类如何实现  <code>只能静态分配</code>  和  <code>只能动态分配</code></a></li><li><a href="#什么情况会自动生成默认构造函数" class="table-of-contents__link toc-highlight">什么情况会自动生成默认构造函数？</a></li><li><a href="#什么是类的继承" class="table-of-contents__link toc-highlight">什么是类的继承？</a></li><li><a href="#抽象基类为什么不能创建对象" class="table-of-contents__link toc-highlight">抽象基类为什么不能创建对象</a></li><li><a href="#类什么时候会析构" class="table-of-contents__link toc-highlight">类什么时候会析构？</a></li><li><a href="#介绍一下c里面的多态" class="table-of-contents__link toc-highlight">介绍一下C++里面的多态？</a></li><li><a href="#用c-语言实现c的继承" class="table-of-contents__link toc-highlight">用C 语言实现C++的继承</a></li><li><a href="#继承机制中对象之间如何转换指针和引用之间如何转换" class="table-of-contents__link toc-highlight">继承机制中对象之间如何转换？指针和引用之间如何转换？</a></li><li><a href="#组合与继承优缺点" class="table-of-contents__link toc-highlight">组合与继承优缺点？</a></li><li><a href="#左值右值" class="table-of-contents__link toc-highlight">左值右值</a></li><li><a href="#c-语言的编译链接过程" class="table-of-contents__link toc-highlight">C 语言的编译链接过程？</a></li><li><a href="#虚函数" class="table-of-contents__link toc-highlight">虚函数</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5a90f2f0.js"></script>
<script src="/assets/js/main.b3b3576b.js"></script>
</body>
</html>